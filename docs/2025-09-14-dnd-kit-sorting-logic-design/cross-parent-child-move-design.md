# Child要素の異なる親間移動機能の設計仕様書

## 概要

現在実装されている同一Parent内でのChild要素並び替え機能を拡張し、異なるParent間でのChild要素移動機能を実装する。この機能により、ユーザーはあるParentのChild要素を別のParentに移動できるようになる。

## 要件分析

### 機能要件

#### REQ-001: 基本的な異なる親間移動

- **説明**: Child要素をドラッグして、異なるParent要素の子要素リストに移動可能
- **制約**: 移動先はParent要素の子要素コンテナ内に限定
- **優先度**: 高

#### REQ-002: ドロップポジション制御

- **説明**: 移動先Parent内での挿入位置を制御可能
- **詳細**:
  - 既存のChild要素間への挿入
  - Parent要素の子要素リストの先頭・末尾への挿入
- **優先度**: 高

#### REQ-003: データ整合性の保証

- **説明**: 移動操作によるデータ構造の整合性を維持
- **詳細**:
  - 移動元からの要素削除
  - 移動先への要素追加
  - 配列インデックスの自動調整
- **優先度**: 高

#### REQ-004: デュアルインターフェース対応

- **説明**: フォーム側とサイドバー側の両方で異なる親間移動をサポート
- **詳細**:
  - フォーム側操作時のサイドバー自動更新
  - サイドバー側操作時のフォーム自動更新
- **優先度**: 高

### 技術要件

#### TECH-001: ID管理の拡張

- **説明**: 異なる親間移動時のID解決とターゲット特定
- **課題**: 現在のChild ID形式（`{parentIndex}-{childIndex}`）は移動時に無効化される
- **解決策**: ドロップターゲットによる動的ID解決

#### TECH-002: ドロップゾーン拡張

- **説明**: Parent要素の子要素コンテナをドロップゾーンとして認識
- **課題**: 現在は同一Parent内のChild要素間のみドロップ対象
- **解決策**: Parent要素の子要素コンテナを新しいドロップターゲットとして追加

#### TECH-003: インジケーター表示の拡張

- **説明**: 異なる親への移動時のドロップインジケーター表示
- **課題**: 現在は同一Parent内でのみインジケーター表示
- **解決策**: Parent要素の`inside`ポジションインジケーターの活用

## 現在の実装分析

### 制限事項

1. **handleChildMove関数の制限**

```typescript
// 現在の実装: 同一Parent内のみ対応
if (activeParentIndex === overParentIndex) {
    // 移動処理
}
// 異なるParent間は未実装
console.log("Cross-parent child move will be implemented in next phase");
```

2. **ドラッグオーバー処理の制限**

```typescript
// 現在: 同一Parent内でのみインジケーター表示
if (activeParentIndex === overParentIndex) {
    // インジケーター表示
}
```

3. **ドロップゾーンの制限**

- Child要素は他のChild要素のみをターゲットとして認識
- Parent要素の子要素コンテナはドロップゾーンとして認識されない

### 拡張ポイント

1. **新しいドロップターゲットタイプの追加**
   - `child`: 既存のChild要素間挿入
   - `parent-container`: Parent要素の子要素コンテナへの挿入

2. **ID解決戦略の拡張**
   - Child要素 → Child要素: 既存ロジック
   - Child要素 → Parent容器: 新規ロジック

3. **データ操作の拡張**
   - 同一Parent内移動: 既存のsplice + insert
   - 異なるParent間移動: source配列からremove + target配列にinsert

## 設計方針

### Phase 1: フォーム側の異なる親間移動

1. **ドロップゾーン拡張**
   - Parent要素の`children-container`をdroppableに設定
   - 新しいドロップターゲットID形式: `parent-container-{parentIndex}`

2. **ドラッグオーバー処理拡張**
   - Child → Parent容器のドラッグオーバー検出
   - Parent容器の`inside`インジケーター表示

3. **移動処理拡張**
   - `handleChildMove`関数の異なるParent間処理追加
   - React Hook Formの複数フィールド更新処理

### Phase 2: サイドバー側の異なる親間移動

1. **サイドバー専用処理の拡張**
   - `handleSidebarChildMove`関数の異なるParent間処理
   - サイドバー専用ID形式への対応

2. **同期処理の確保**
   - サイドバー操作によるフォーム状態の同期更新

### Phase 3: テストケースの実装

1. **E2Eテストの有効化**
   - 現在skip状態のテストケースを有効化
   - 新しいテストシナリオの追加

## 実装ステップ

### Step 1: ドロップゾーン拡張

- Parent要素の子要素コンテナをdroppableとして設定
- 新しいID形式の導入と既存システムとの互換性確保

### Step 2: ドラッグオーバー処理拡張

- Child → Parent容器の検出ロジック追加
- インジケーター表示ロジックの拡張

### Step 3: 移動処理実装

- `handleChildMove`の異なるParent間処理追加
- データ整合性とフォーム状態の同期確保

### Step 4: サイドバー対応

- サイドバー側の異なるParent間移動処理実装
- デュアルインターフェース同期の確保

### Step 5: テスト実装

- E2Eテストケースの実装と検証
- 回帰テストの実行

## リスクと対策

### リスク1: データ整合性の破綻

- **対策**: 移動処理をトランザクション的に実行
- **検証**: 移動前後のデータ検証ロジック追加

### リスク2: パフォーマンスの劣化

- **対策**: 大量データでの動作検証
- **最適化**: 必要最小限のフィールド更新

### リスク3: UI/UXの混乱

- **対策**: 明確なドロップインジケーター表示
- **検証**: ユーザビリティテストの実施

## 次のステップ

1. Step 1から段階的に実装開始
2. 各Stepでの動作検証とテスト実行
3. フィードバックに基づく設計調整
